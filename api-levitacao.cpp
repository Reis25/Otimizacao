/**
 * api-levitacao.cpp
 *
 * Driver class with a simple example of how to instantiate and use the BRKGA API.
 * See SampleDecoder.h for details on the decoder's implementation.
 *
 * Created on : Nov 17, 2011 by rtoso
 * Authors    : Rodrigo Franco Toso <rtoso@cs.rutgers.edu>
 *              Mauricio G.C. Resende <mgcr@research.att.com>
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2018
 * Rodrigo Franco Toso (rfrancotoso@gmail.com) and
 * Mauricio G.C. Resende
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#include <iostream>
#include <algorithm>
#include "brkgaAPI/BRKGA.h"
#include "brkgaAPI/MTRand.h"
#include "busca_decode.h"
#include <vector>

int main(int argc,char* argv[]) {
  

 

  std::cout << "Welcome to the BRKGA API sample driver.\nFinding a (heuristic)  "
      << " maximize f(n)) where f(n) nÂ²/n" << std::endl;
 
  const std::string instanceFile = std::string(argv[1]);
  std::cout << "Instance file: " << instanceFile << std::endl;

  const unsigned n = 100;    // size of chromosomes
  const unsigned p = 100;    // size of population
  const double pe = 0.20;    // fraction of population to be the elite-set
  const double pm = 0.10;    // fraction of population to be replaced by mutants
  const double rhoe = 0.70;  // probability that offspring inherit an allele from elite parent
  const unsigned K = 3;      // number of independent populations
  const unsigned MAXT = 1;   // number of threads for parallel decoding
  
  busca_decode decoder; 
  decoder.qualquer =instanceFile;

      
  const long unsigned rngSeed = 0;  // seed to the random number generator
  MTRand rng(rngSeed);        // initialize the random number generator
  
  // initialize the BRKGA-based heuristic
  BRKGA< busca_decode, MTRand > algorithm(n, p, pe, pm, rhoe, decoder, rng, K, MAXT);
  
  unsigned generation = 0;    // current generation
  const unsigned X_INTVL = 100;  // exchange best individuals at every 100 generations
  const unsigned X_NUMBER = 2;  // exchange top 2 best
  const unsigned MAX_GENS = 1000;  // run for 1000 gens
  std::cout << "Running for " << MAX_GENS << " generations..." << std::endl;
  do {
    algorithm.evolve();  // evolve the population for one generation
    
    if((++generation) % X_INTVL == 0) {
      algorithm.exchangeElite(X_NUMBER);  // exchange top individuals
    }
  } while (generation < MAX_GENS);
  
  // print the fitness of the top 10 individuals of each population:
  std::cout << "Fitness of the top 10 individuals of each population:" << std::endl;
  const unsigned bound = std::min(p, unsigned(10));  // makes sure we have 10 individuals
  for(unsigned i = 0; i < K; ++i) {
    std::cout << "Population #" << i << ":" << std::endl;
    for(unsigned j = 0; j < bound; ++j) {
      std::cout << "\t" << j << ") "
          << algorithm.getPopulation(i).getFitness(j) << std::endl;
    }
  }
  
  std::cout << "Best solution found has objective value = "
       << algorithm.getBestFitness() << std::endl;
  
  
    
  return 0;

}